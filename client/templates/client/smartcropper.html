<!DOCTYPE html>
<html lang="zh-TW">
<head>
<meta charset="UTF-8">
<title>Text Density Detection - Auto Crop with Adjustment</title>
<script async src="https://docs.opencv.org/4.x/opencv.js"></script>
<style>
body {
    font-family: Arial, sans-serif;
    padding: 20px;
}
canvas {
    border: 1px solid #000;
    margin: 6px;
    max-width: 100%;
}
.controls {
    background: #f0f0f0;
    padding: 15px;
    margin: 10px 0;
    border-radius: 5px;
}
.control-group {
    margin: 10px 0;
}
label {
    display: inline-block;
    width: 150px;
    font-weight: bold;
}
input[type="range"] {
    width: 200px;
}
button {
    background: #4CAF50;
    color: white;
    padding: 10px 20px;
    border: none;
    border-radius: 4px;
    cursor: pointer;
    margin: 5px;
}
button:hover {
    background: #45a049;
}
button:disabled {
    background: #cccccc;
    cursor: not-allowed;
}
.crop-controls {
    background: #e3f2fd;
    padding: 15px;
    margin: 10px 0;
    border-radius: 5px;
}
</style>
</head>
<body>

<h2>文字密度偵測 + 自動裁切（可調整）</h2>

<div class="controls">
    <input type="file" id="fileInput" accept="image/*">
    <button id="detectBtn" disabled>重新偵測</button>
</div>

<div class="crop-controls" id="cropControls" style="display:none;">
    <h3>裁切框調整</h3>
    <div class="control-group">
        <label>上邊距:</label>
        <input type="range" id="topMargin" min="-500" max="500" value="0">
        <span id="topValue">0</span> px
    </div>
    <div class="control-group">
        <label>下邊距:</label>
        <input type="range" id="bottomMargin" min="-500" max="500" value="0">
        <span id="bottomValue">0</span> px
    </div>
    <div class="control-group">
        <label>左邊距:</label>
        <input type="range" id="leftMargin" min="-500" max="500" value="0">
        <span id="leftValue">0</span> px
    </div>
    <div class="control-group">
        <label>右邊距:</label>
        <input type="range" id="rightMargin" min="-500" max="500" value="0">
        <span id="rightValue">0</span> px
    </div>
    <button id="applyCropBtn">套用裁切</button>
    <button id="downloadBtn">下載裁切圖片</button>
    <button id="resetBtn">重置調整</button>
</div>

<h3>偵測結果（紅框）</h3>
<canvas id="canvasResult"></canvas>

<h3>裁切預覽</h3>
<canvas id="canvasCropped"></canvas>

<h3>原圖</h3>
<canvas id="canvasInput"></canvas>

<h3>二值化</h3>
<canvas id="canvasBinary"></canvas>

<h3>邊緣偵測</h3>
<canvas id="canvasEdges"></canvas>



<script>
const fileInput = document.getElementById('fileInput');
const detectBtn = document.getElementById('detectBtn');
const canvasInput = document.getElementById('canvasInput');
const canvasBinary = document.getElementById('canvasBinary');
const canvasEdges = document.getElementById('canvasEdges');
const canvasResult = document.getElementById('canvasResult');
const canvasCropped = document.getElementById('canvasCropped');

const cropControls = document.getElementById('cropControls');
const topMargin = document.getElementById('topMargin');
const bottomMargin = document.getElementById('bottomMargin');
const leftMargin = document.getElementById('leftMargin');
const rightMargin = document.getElementById('rightMargin');
const applyCropBtn = document.getElementById('applyCropBtn');
const downloadBtn = document.getElementById('downloadBtn');
const resetBtn = document.getElementById('resetBtn');

let originalImage = null;
let detectedRect = null;
let currentSrc = null;

// 更新顯示值
topMargin.oninput = () => document.getElementById('topValue').textContent = topMargin.value;
bottomMargin.oninput = () => document.getElementById('bottomValue').textContent = bottomMargin.value;
leftMargin.oninput = () => document.getElementById('leftValue').textContent = leftMargin.value;
rightMargin.oninput = () => document.getElementById('rightValue').textContent = rightMargin.value;

fileInput.addEventListener('change', e => {
    const img = new Image();
    img.onload = () => {
        originalImage = img;
        canvasInput.width = img.width;
        canvasInput.height = img.height;
        canvasInput.getContext('2d').drawImage(img, 0, 0);
        detectBtn.disabled = false;
        detectTextRegions();
    };
    img.src = URL.createObjectURL(e.target.files[0]);
});

detectBtn.addEventListener('click', detectTextRegions);
applyCropBtn.addEventListener('click', updateCrop);
resetBtn.addEventListener('click', () => {
    topMargin.value = 0;
    bottomMargin.value = 0;
    leftMargin.value = 0;
    rightMargin.value = 0;
    topMargin.oninput();
    bottomMargin.oninput();
    leftMargin.oninput();
    rightMargin.oninput();
    updateCrop();
});

downloadBtn.addEventListener('click', () => {
    const link = document.createElement('a');
    link.download = 'cropped_image.png';
    link.href = canvasCropped.toDataURL();
    link.click();
});

/* ======================
   Geometry utilities
====================== */

function rectOverlap(a, b) {
    return !(
        b.x > a.x + a.width ||
        b.x + b.width < a.x ||
        b.y > a.y + a.height ||
        b.y + b.height < a.y
    );
}

function mergeRect(a, b) {
    const x1 = Math.min(a.x, b.x);
    const y1 = Math.min(a.y, b.y);
    const x2 = Math.max(a.x + a.width, b.x + b.width);
    const y2 = Math.max(a.y + a.height, b.y + b.height);
    return { x: x1, y: y1, width: x2 - x1, height: y2 - y1 };
}

function mergeOverlappingRects(rects) {
    let merged = [];

    for (let r of rects) {
        let mergedOnce = false;
        for (let i = 0; i < merged.length; i++) {
            if (rectOverlap(r, merged[i])) {
                merged[i] = mergeRect(r, merged[i]);
                mergedOnce = true;
                break;
            }
        }
        if (!mergedOnce) merged.push(r);
    }

    let changed = true;
    while (changed) {
        changed = false;
        for (let i = 0; i < merged.length; i++) {
            for (let j = i + 1; j < merged.length; j++) {
                if (rectOverlap(merged[i], merged[j])) {
                    merged[i] = mergeRect(merged[i], merged[j]);
                    merged.splice(j, 1);
                    changed = true;
                    j--;
                }
            }
        }
    }
    return merged;
}

/* ======================
   Main detection
====================== */

function detectTextRegions() {
    let src = cv.imread(canvasInput);
    currentSrc = src.clone();
    let gray = new cv.Mat();
    let blur = new cv.Mat();
    let binary = new cv.Mat();
    let edges = new cv.Mat();

    // 灰階 + 模糊
    cv.cvtColor(src, gray, cv.COLOR_RGBA2GRAY);
    cv.GaussianBlur(gray, blur, new cv.Size(5, 5), 0);

    // 自適應二值化（文字 → 白）
    cv.adaptiveThreshold(
        blur, binary, 255,
        cv.ADAPTIVE_THRESH_GAUSSIAN_C,
        cv.THRESH_BINARY_INV,
        15, 10
    );

    // 邊緣 + 膨脹（文字聚合）
    cv.Canny(binary, edges, 40, 120);
    let kernel = cv.getStructuringElement(
        cv.MORPH_RECT, new cv.Size(25, 25)
    );
    cv.dilate(edges, edges, kernel);

    // 找輪廓
    let contours = new cv.MatVector();
    let hierarchy = new cv.Mat();
    cv.findContours(
        edges, contours, hierarchy,
        cv.RETR_EXTERNAL, cv.CHAIN_APPROX_SIMPLE
    );

    /* ======================
       排除靠近圖片邊界
    ====================== */

    const minArea = 800;
    const marginRatio = 0.05;

    const marginX = src.cols * marginRatio;
    const marginY = src.rows * marginRatio;

    let rects = [];

    for (let i = 0; i < contours.size(); i++) {
        let rect = cv.boundingRect(contours.get(i));
        let area = rect.width * rect.height;

        if (area < minArea) continue;

        if (
            rect.x <= marginX ||
            rect.y <= marginY ||
            rect.x + rect.width >= src.cols - marginX ||
            rect.y + rect.height >= src.rows - marginY
        ) {
            continue;
        }

        rects.push(rect);
    }

    // 先合併「實際重疊」的框
    let mergedRects = mergeOverlappingRects(rects);

    /* ======================
       找最大框 + 合併上下框 + 取最外圍左右邊界
    ====================== */
    
    if (mergedRects.length > 0) {
        // 1. 找到面積最大的框
        let maxRect = mergedRects.reduce((prev, curr) =>
            (curr.width * curr.height > prev.width * prev.height) ? curr : prev
        );

        // 2. 找出所有在垂直方向上與最大框有重疊的框
        let verticalOverlapRects = mergedRects.filter(r => {
            return !(r.x + r.width < maxRect.x || r.x > maxRect.x + maxRect.width);
        });

        // 3. 取所有框的最外圍邊界
        let minX = Math.min(...verticalOverlapRects.map(r => r.x));
        let maxX = Math.max(...verticalOverlapRects.map(r => r.x + r.width));
        let minY = Math.min(...verticalOverlapRects.map(r => r.y));
        let maxY = Math.max(...verticalOverlapRects.map(r => r.y + r.height));

        // 4. 建立合併後的單一框
        detectedRect = {
            x: minX,
            y: minY,
            width: maxX - minX,
            height: maxY - minY
        };
        
        mergedRects = [detectedRect];
        
        // 顯示裁切控制項
        cropControls.style.display = 'block';
    } else {
        detectedRect = null;
        cropControls.style.display = 'none';
    }

    /* ======================
       畫結果
    ====================== */
    
    let result = src.clone();
    
    for (let r of mergedRects) {
        cv.rectangle(
            result,
            new cv.Point(r.x, r.y),
            new cv.Point(r.x + r.width, r.y + r.height),
            [255, 0, 0, 255],
            3
        );
    }

    // 顯示
    cv.imshow(canvasBinary, binary);
    cv.imshow(canvasEdges, edges);
    canvasResult.width = src.cols;
    canvasResult.height = src.rows;
    cv.imshow(canvasResult, result);

    // 自動套用裁切
    updateCrop();

    // 清理
    src.delete(); gray.delete(); blur.delete();
    binary.delete(); edges.delete();
    contours.delete(); hierarchy.delete(); result.delete();
}

/* ======================
   裁切功能
====================== */

function updateCrop() {
    if (!detectedRect || !currentSrc) return;

    const top = parseInt(topMargin.value);
    const bottom = parseInt(bottomMargin.value);
    const left = parseInt(leftMargin.value);
    const right = parseInt(rightMargin.value);

    // 計算裁切區域（加上調整值）
    let cropX = Math.max(0, detectedRect.x + left);
    let cropY = Math.max(0, detectedRect.y + top);
    let cropWidth = Math.min(currentSrc.cols - cropX, detectedRect.width - left + right);
    let cropHeight = Math.min(currentSrc.rows - cropY, detectedRect.height - top + bottom);

    // 確保尺寸有效
    if (cropWidth <= 0 || cropHeight <= 0) {
        console.error('Invalid crop dimensions');
        return;
    }

    // 建立裁切區域
    let rect = new cv.Rect(cropX, cropY, cropWidth, cropHeight);
    let cropped = currentSrc.roi(rect);

    // 顯示裁切結果
    canvasCropped.width = cropWidth;
    canvasCropped.height = cropHeight;
    cv.imshow(canvasCropped, cropped);

    // 在結果圖上畫調整後的框（綠色虛線）
    let result = currentSrc.clone();
    cv.rectangle(
        result,
        new cv.Point(detectedRect.x, detectedRect.y),
        new cv.Point(detectedRect.x + detectedRect.width, detectedRect.y + detectedRect.height),
        [255, 0, 0, 255],
        3
    );
    cv.rectangle(
        result,
        new cv.Point(cropX, cropY),
        new cv.Point(cropX + cropWidth, cropY + cropHeight),
        [0, 255, 0, 255],
        2
    );
    
    canvasResult.width = currentSrc.cols;
    canvasResult.height = currentSrc.rows;
    cv.imshow(canvasResult, result);

    cropped.delete();
    result.delete();
}

// 即時更新裁切預覽
topMargin.addEventListener('input', updateCrop);
bottomMargin.addEventListener('input', updateCrop);
leftMargin.addEventListener('input', updateCrop);
rightMargin.addEventListener('input', updateCrop);

</script>
</body>
</html>